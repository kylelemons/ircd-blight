package main

import (
	"bytes"
	"exec"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"runtime"
	"strings"
)

var (
	pkg  = flag.String("pkg", "watermark", "The package for the generated source file")
	out  = flag.String("out", "-", "The Go source file to store the watermark")
	proj = flag.String("project", "", "The name of the project (prefix to REPO_VERSION)")
)

func runCommand(args ...string) string {
	cmd := args[0]

	binary, err := exec.LookPath(cmd)
	if err != nil {
		log.Fatalf("Could not find `%s`: %s", cmd, err)
	}

	runner, err := exec.Run(binary, args, nil, "", exec.DevNull, exec.Pipe, exec.Pipe)
	if err != nil {
		log.Fatalf("Could not run `%s`: %s", strings.Join(args, " "), err)
	}

	wm, err := runner.Wait(0)
	if err != nil {
		log.Fatalf("Error running `%s`: %s", strings.Join(args, " "), err)
	}

	status := wm.WaitStatus.ExitStatus()
	if status != 0 {
		log.Printf("Error in `%s` (exit code %d):", strings.Join(args, " "), err)
		io.Copy(os.Stderr, runner.Stderr)
		os.Exit(1)
	}

	outbuf := bytes.NewBuffer(nil)
	io.Copy(outbuf, runner.Stdout)
	outbytes := outbuf.Bytes()
	return string(bytes.TrimSpace(outbytes))
}

func main() {
	flag.Parse()

	var fout io.Writer = os.Stdout
	if *out != "-" {
		fout = bytes.NewBuffer(nil)
	}

	host, err := os.Hostname()
	if err != nil {
		log.Fatalf("Could not get hostname: %s", err)
	}

	goVersion := runtime.Version()

	tag := runCommand("git", "describe")
	if project := *proj; len(project) > 0 {
		tag = project + "-" + tag
	}

	fmt.Fprintf(fout, "// Autogenerated by watermark\npackage %s\n\n", *pkg)
	fmt.Fprintf(fout, "const (\n")
	fmt.Fprintf(fout, "\tGO_VERSION = %q\n", goVersion)
	fmt.Fprintf(fout, "\tREPO_VERSION = %q\n", tag)
	fmt.Fprintf(fout, "\tCOMPILE_HOST = %q\n", host)
	fmt.Fprintf(fout, ")\n")

	if buf, ok := fout.(*bytes.Buffer); ok {
		err := ioutil.WriteFile(*out, buf.Bytes(), 0666)
		if err != nil {
			log.Fatalf("WriteFile(%q): %s", *out, err)
		}
	}
}
