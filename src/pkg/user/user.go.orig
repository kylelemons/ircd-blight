package user

import (
	"sync"
)

var (
	userMutex = new(sync.Mutex)
<<<<<<< Updated upstream
	userMap   = make(map[string]*User)
	userIDs   = make(chan string)
=======
	userMap = make(map[string]*User)
	userIDs = make(chan string)
>>>>>>> Stashed changes
)

var (
	UserIDPrefix = "000"
)

func genUserIDs() {
	chars := []byte{'A', 'A', 'A', 'A', 'A', 'A'}
	for {
		userIDs <- string(chars)
<<<<<<< Updated upstream
		for i := len(chars) - 1; i >= 0; i-- {
			switch chars[i] {
			case '9':
				chars[i] = 'A'
				continue
			case 'Z':
				chars[i] = '0'
			default:
				chars[i]++
=======
		for i := len(chars)-1; i >= 0; i-- {
			switch chars[i] {
				case '9':
					chars[i] = 'A'
					continue
				case 'Z':
					chars[i] = '0'
				default:
					chars[i]++
>>>>>>> Stashed changes
			}
			break
		}
	}
}

type User struct {
	mutex *sync.RWMutex
<<<<<<< Updated upstream
	id    string
	User  string
	Nick  string
	Name  string
=======
	id string
	User string
	Nick string
	Name string
>>>>>>> Stashed changes
}

func NextUserID() string {
	return UserIDPrefix + <-userIDs
}

func NewUser(id string) *User {
	userMutex.Lock()
	defer userMutex.Unlock()

	// Database lookup
	if u, ok := userMap[id]; ok {
		return u
	}

	u := &User{
		mutex: new(sync.RWMutex),
<<<<<<< Updated upstream
		id:    id,
=======
		id: id,
>>>>>>> Stashed changes
	}

	userMap[id] = u
	return u
}

func (u *User) Login(user, nick, name string) {
	u.User, u.Nick, u.Name = user, nick, name
}

func init() {
	go genUserIDs()
}
